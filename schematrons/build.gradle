schemaDir=project(":web").file("src/main/webapp/xml/schemas")
defaultLang='en'
schemas = schemaDir.listFiles().findAll{it.isDirectory()}

allRules = file('rules').listFiles().findAll{it.isFile()}.collect{
  it.name.drop("schematron-rules-".length()).reverse().drop(4).reverse()
}
// Declares where to publish rules
rulesToPublish = [
  /iso19139.*/:['geonetwork', 'iso', 'inspire','iso-che'],
  /(csw-record)|(fgdc-std)|(iso19115)|(dublin-core)|(iso19110)/:['schematron-rules-none.sch'],
]
// If no rules in rulesToPublish are found then the following rules will be used
defaultRules = 

task cleanSchematronFiles << {
  schemas.each {
    fileTree(dir: it, includes: ['schematron-rules-*.xsl*','**/schematron-rules-*.xml'], excludes: ['schematron*-che*']).each{it.delete()}
  }
}

task publishAll{
  rulesToPublish.each {dependsOn "publish"+it.capitalize()}
}

rulesToPublish.each { ruleDef ->
  def rule = ruleDef.value
  def schemaMatchRegex = ruleDef.key
  task ("publish"+rule.capitalize()) {
    inputs.file rulesInputFile(rule)
    inputs.files fileTree(dir: "rules/loc", include: "**/${locFileName(rule)}")
    def matchedSchemas = schemas.findAll {it ==~ schemaMatchRegex}
    matchedSchemas each {
      outputs.files fileTree(dir: it, includes: ['schematron-rules-*.xsl*','**/schematron-rules-*.xml'])
    }
    
    doLast {
      compileRules(rule)
  
      matchedSchemas.each{publish(rule, it)}
    }
  }
}

def rulesInputFile(rules) {return file("rules/schematron-rules-${rules}.sch")}

def compiledRules(rules) {
  return file("${buildDir}/schematron-rules-${rules}.xsl")
}

def compileRules(rules) {
  ant.xslt(
    basedir:projectDir,
    style:file("resources/iso_svrl_for_xslt2.xsl").path,
	  in:rulesInputFile(rules).path,
	  out: compiledRules(rules)) {
	    classpath {
	      pathelement(location: file("saxon9.jar"))
	    }
	  }
}

def locFileName(rules) {return "schematron-rules-${rules}.xml"}

def publish(rules, schema) {
  logger.info("Copy schematron $rules XSLT to $schema schema.")
  def from = compiledRules(rules)
  def to = file("$schema/schematron-rules-${rules}.xsl")
  to.delete()
  to << from.bytes
  
  def defaultLocFile = file("rules/loc/$defaultLang/${locFileName(rules)}").bytes
  file("rules/loc").listFiles().each { locDir ->
    def toFile = file("$schema/loc/${locDir.name}/${locFileName(rules)}")
    def fromFile = file("$locDir/${locFileName(rules)}")
    toFile.delete()
    toFile.parentFile.mkdirs()
    if(toFile.parentFile.exists()) {
      // if fromFile does not exist write the default
      if(fromFile.exists()) {
        toFile << fromFile.bytes
      } else {
        toFile << defaultLocFile
      }
    }
  }
}